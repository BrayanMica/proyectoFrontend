-- PostgreSQL script for SaludPlus healthcare platform
-- Using Supabase with FastAPI backend

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Custom Types
CREATE TYPE public.gender_type AS ENUM ('male', 'female', 'other');
CREATE TYPE public.appointment_status AS ENUM ('pending', 'attended', 'cancelled_by_patient', 'cancelled_by_doctor');
CREATE TYPE public.app_role AS ENUM ('admin', 'doctor', 'patient');
CREATE TYPE public.app_permission AS ENUM (
    'patient.read', 'patient.create', 'patient.update', 'patient.delete',
    'doctor.read', 'doctor.create', 'doctor.update', 'doctor.delete',
    'appointment.read', 'appointment.create', 'appointment.update', 'appointment.delete',
    'schedule.read', 'schedule.create', 'schedule.update', 'schedule.delete',
    'approval.patient', 'approval.doctor', 'report.generate'
);
CREATE TYPE public.day_of_week AS ENUM ('monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday');
CREATE TYPE public.approval_status AS ENUM ('pending', 'approved', 'rejected');

-- Specialties Table
CREATE TABLE public.specialties (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Patient Profiles Table
CREATE TABLE public.patient_profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    dpi TEXT NOT NULL UNIQUE,
    gender gender_type NOT NULL,
    address TEXT NOT NULL,
    phone TEXT NOT NULL,
    birth_date DATE NOT NULL,
    photo_url TEXT,
    approval_status approval_status DEFAULT 'pending',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Doctor Profiles Table
CREATE TABLE public.doctor_profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    dpi TEXT NOT NULL UNIQUE,
    gender gender_type NOT NULL,
    birth_date DATE NOT NULL,
    address TEXT NOT NULL,
    phone TEXT NOT NULL,
    photo_url TEXT NOT NULL,
    license_number TEXT NOT NULL UNIQUE,
    specialty_id UUID REFERENCES public.specialties(id),
    clinic_address TEXT NOT NULL,
    approval_status approval_status DEFAULT 'pending',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Doctor Schedules Table
CREATE TABLE public.doctor_schedules (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    doctor_id UUID NOT NULL REFERENCES public.doctor_profiles(id) ON DELETE CASCADE,
    day day_of_week NOT NULL,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (doctor_id, day)
);

-- Appointments Table (CORRECTED)
CREATE TABLE public.appointments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    patient_id UUID NOT NULL REFERENCES public.patient_profiles(id) ON DELETE CASCADE,
    doctor_id UUID NOT NULL REFERENCES public.doctor_profiles(id) ON DELETE CASCADE,
    appointment_date DATE NOT NULL,
    appointment_time TIME NOT NULL,
    reason TEXT NOT NULL,
    treatment TEXT,
    status appointment_status NOT NULL DEFAULT 'pending',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create partial unique indices for appointments (CORRECTED)
CREATE UNIQUE INDEX unique_doctor_patient_pending_appointment
ON public.appointments (doctor_id, patient_id)
WHERE status = 'pending';

CREATE UNIQUE INDEX unique_doctor_datetime_pending_appointment
ON public.appointments (doctor_id, appointment_date, appointment_time)
WHERE status = 'pending';

-- User Roles Table
CREATE TABLE public.user_roles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    role app_role NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (user_id, role)
);

-- Role Permissions Table
CREATE TABLE public.role_permissions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role app_role NOT NULL,
    permission app_permission NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (role, permission)
);

-- Admin Configuration
CREATE TABLE public.admin_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    second_factor_password TEXT NOT NULL, -- Hashed second factor password
    email TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Insert default admin
INSERT INTO public.admin_config (email, second_factor_password)
VALUES ('albertoha2000@gmail.com', crypt('admin123', gen_salt('bf')));

-- Insert Initial Roles and Permissions
INSERT INTO public.role_permissions (role, permission)
VALUES
    -- Admin permissions
    ('admin', 'patient.read'),
    ('admin', 'patient.create'),
    ('admin', 'patient.update'),
    ('admin', 'patient.delete'),
    ('admin', 'doctor.read'),
    ('admin', 'doctor.create'),
    ('admin', 'doctor.update'),
    ('admin', 'doctor.delete'),
    ('admin', 'approval.patient'),
    ('admin', 'approval.doctor'),
    ('admin', 'report.generate'),
    
    -- Doctor permissions
    ('doctor', 'patient.read'),
    ('doctor', 'appointment.read'),
    ('doctor', 'appointment.update'),
    ('doctor', 'appointment.delete'),
    ('doctor', 'schedule.read'),
    ('doctor', 'schedule.create'),
    ('doctor', 'schedule.update'),
    
    -- Patient permissions
    ('patient', 'doctor.read'),
    ('patient', 'appointment.read'),
    ('patient', 'appointment.create'),
    ('patient', 'appointment.update'),
    ('patient', 'appointment.delete');

-- Initial specialties
INSERT INTO public.specialties (name) 
VALUES 
    ('General Medicine'),
    ('Cardiology'),
    ('Dermatology'),
    ('Neurology'),
    ('Pediatrics'),
    ('Orthopedics'),
    ('Gynecology'),
    ('Psychiatry'),
    ('Ophthalmology'),
    ('Otorhinolaryngology');

-- FUNCTIONS AND TRIGGERS

-- Function to update timestamps
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Timestamp triggers
CREATE TRIGGER update_patient_profiles_timestamp 
BEFORE UPDATE ON public.patient_profiles 
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_doctor_profiles_timestamp 
BEFORE UPDATE ON public.doctor_profiles 
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_doctor_schedules_timestamp 
BEFORE UPDATE ON public.doctor_schedules 
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_appointments_timestamp 
BEFORE UPDATE ON public.appointments 
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_specialties_timestamp 
BEFORE UPDATE ON public.specialties 
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_admin_config_timestamp 
BEFORE UPDATE ON public.admin_config 
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

-- Function to check if appointment time is valid
CREATE OR REPLACE FUNCTION check_appointment_time()
RETURNS TRIGGER AS $$
DECLARE
    doctor_day day_of_week;
    schedule_exists BOOLEAN;
    day_matches BOOLEAN;
    time_within_range BOOLEAN;
BEGIN
    -- Convert date to day of week
    SELECT TO_CHAR(NEW.appointment_date, 'day') INTO doctor_day;
    doctor_day := TRIM(doctor_day);
    doctor_day := LOWER(doctor_day);

    -- Check if doctor works on this day
    SELECT EXISTS (
        SELECT 1 FROM public.doctor_schedules 
        WHERE doctor_id = NEW.doctor_id 
        AND day = doctor_day::day_of_week
    ) INTO day_matches;

    IF NOT day_matches THEN
        RAISE EXCEPTION 'Doctor does not work on this day';
    END IF;

    -- Check if time is within doctor's working hours
    SELECT EXISTS (
        SELECT 1 FROM public.doctor_schedules 
        WHERE doctor_id = NEW.doctor_id 
        AND day = doctor_day::day_of_week
        AND NEW.appointment_time BETWEEN start_time AND end_time
    ) INTO time_within_range;

    IF NOT time_within_range THEN
        RAISE EXCEPTION 'Appointment time is outside doctor''s working hours';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_appointment_time_trigger
BEFORE INSERT OR UPDATE ON public.appointments
FOR EACH ROW EXECUTE FUNCTION check_appointment_time();

-- Function to validate one pending appointment per doctor-patient pair
CREATE OR REPLACE FUNCTION check_one_pending_appointment()
RETURNS TRIGGER AS $$
DECLARE
    existing_count INTEGER;
BEGIN
    -- Count existing pending appointments for this doctor-patient pair
    SELECT COUNT(*) INTO existing_count
    FROM public.appointments
    WHERE doctor_id = NEW.doctor_id
    AND patient_id = NEW.patient_id
    AND status = 'pending';
    
    IF existing_count > 0 AND TG_OP = 'INSERT' THEN
        RAISE EXCEPTION 'Patient already has a pending appointment with this doctor';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_one_pending_appointment_trigger
BEFORE INSERT ON public.appointments
FOR EACH ROW EXECUTE FUNCTION check_one_pending_appointment();

-- Function to check doctor availability
CREATE OR REPLACE FUNCTION check_doctor_availability()
RETURNS TRIGGER AS $$
DECLARE
    existing_count INTEGER;
BEGIN
    -- Check if doctor already has an appointment at this time
    SELECT COUNT(*) INTO existing_count
    FROM public.appointments
    WHERE doctor_id = NEW.doctor_id
    AND appointment_date = NEW.appointment_date
    AND appointment_time = NEW.appointment_time
    AND status = 'pending'
    AND id != NEW.id; -- Exclude the current appointment in case of update
    
    IF existing_count > 0 THEN
        RAISE EXCEPTION 'Doctor already has an appointment at this time';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_doctor_availability_trigger
BEFORE INSERT OR UPDATE ON public.appointments
FOR EACH ROW EXECUTE FUNCTION check_doctor_availability();

-- Function for JWT custom claims
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event JSONB)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    claims JSONB;
    user_role public.app_role;
    is_admin BOOLEAN;
    is_doctor BOOLEAN;
    is_patient BOOLEAN;
    user_id UUID;
BEGIN
    user_id := (event->>'user_id')::UUID;
    claims := event->'claims';

    -- Check user roles
    SELECT EXISTS (
        SELECT 1 FROM public.user_roles 
        WHERE user_id = user_id AND role = 'admin'
    ) INTO is_admin;

    SELECT EXISTS (
        SELECT 1 FROM public.user_roles 
        WHERE user_id = user_id AND role = 'doctor'
    ) INTO is_doctor;

    SELECT EXISTS (
        SELECT 1 FROM public.user_roles 
        WHERE user_id = user_id AND role = 'patient'
    ) INTO is_patient;

    -- Set role claims
    claims := jsonb_set(claims, '{is_admin}', to_jsonb(is_admin));
    claims := jsonb_set(claims, '{is_doctor}', to_jsonb(is_doctor));
    claims := jsonb_set(claims, '{is_patient}', to_jsonb(is_patient));

    -- If user has a specific primary role, add it
    IF is_admin THEN
        user_role := 'admin';
    ELSIF is_doctor THEN
        user_role := 'doctor';
    ELSIF is_patient THEN
        user_role := 'patient';
    END IF;

    IF user_role IS NOT NULL THEN
        claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    END IF;

    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);
    RETURN event;
END;
$$;

-- Function to check permissions for a role
CREATE OR REPLACE FUNCTION public.authorize(requested_permission app_permission)
RETURNS BOOLEAN AS $$
DECLARE
    bind_permissions INTEGER;
    user_role public.app_role;
BEGIN
    -- Get the user's role from JWT
    SELECT (auth.jwt() ->> 'user_role')::public.app_role INTO user_role;
    
    -- Check if the user has the requested permission
    SELECT COUNT(*)
    INTO bind_permissions
    FROM public.role_permissions
    WHERE role_permissions.permission = requested_permission
    AND role_permissions.role = user_role;
    
    RETURN bind_permissions > 0;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = '';

-- Function to automatically set role when signing up
CREATE OR REPLACE FUNCTION public.handle_new_user() 
RETURNS TRIGGER AS $$
BEGIN
    -- Check email domain or pattern to determine role
    -- This is a simple example; you might want more sophisticated logic
    IF NEW.email LIKE '%admin%' THEN
        INSERT INTO public.user_roles (user_id, role) VALUES (NEW.id, 'admin');
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for handling new users
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Function to assign patient role on profile creation
CREATE OR REPLACE FUNCTION public.assign_patient_role()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.user_roles (user_id, role)
    VALUES (NEW.id, 'patient')
    ON CONFLICT (user_id, role) DO NOTHING;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to assign doctor role on profile creation
CREATE OR REPLACE FUNCTION public.assign_doctor_role()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.user_roles (user_id, role)
    VALUES (NEW.id, 'doctor')
    ON CONFLICT (user_id, role) DO NOTHING;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Triggers for role assignment
CREATE TRIGGER assign_patient_role_trigger
AFTER INSERT ON public.patient_profiles
FOR EACH ROW EXECUTE FUNCTION public.assign_patient_role();

CREATE TRIGGER assign_doctor_role_trigger
AFTER INSERT ON public.doctor_profiles
FOR EACH ROW EXECUTE FUNCTION public.assign_doctor_role();

-- Function to verify admin second factor
CREATE OR REPLACE FUNCTION public.verify_admin_second_factor(admin_email TEXT, password_to_check TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    stored_password TEXT;
BEGIN
    SELECT second_factor_password INTO stored_password
    FROM public.admin_config
    WHERE email = admin_email;
    
    RETURN stored_password IS NOT NULL AND 
           stored_password = crypt(password_to_check, stored_password);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get available time slots for a doctor on a specific date
CREATE OR REPLACE FUNCTION public.get_available_time_slots(
    doctor_id UUID,
    date_to_check DATE
)
RETURNS TABLE (
    available_slot TIME
) AS $$
DECLARE
    day_to_check day_of_week;
    start_hour TIME;
    end_hour TIME;
    slot_interval INTERVAL := '30 minutes';
    current_slot TIME;
BEGIN
    -- Convert date to day of week
    SELECT TO_CHAR(date_to_check, 'day') INTO day_to_check;
    day_to_check := TRIM(day_to_check);
    day_to_check := LOWER(day_to_check);

    -- Get doctor's schedule for this day
    SELECT start_time, end_time INTO start_hour, end_hour
    FROM public.doctor_schedules
    WHERE doctor_schedules.doctor_id = get_available_time_slots.doctor_id
    AND day = day_to_check::day_of_week;

    -- Return empty set if no schedule found for this day
    IF start_hour IS NULL THEN
        RETURN;
    END IF;

    -- Generate all slots from start to end
    current_slot := start_hour;
    WHILE current_slot < end_hour LOOP
        -- Check if slot is available (not booked)
        IF NOT EXISTS (
            SELECT 1 FROM public.appointments
            WHERE appointments.doctor_id = get_available_time_slots.doctor_id
            AND appointment_date = date_to_check
            AND appointment_time = current_slot
            AND status = 'pending'
        ) THEN
            available_slot := current_slot;
            RETURN NEXT;
        END IF;
        
        -- Move to next slot
        current_slot := current_slot + slot_interval;
    END LOOP;
    
    RETURN;
END;
$$ LANGUAGE plpgsql;

-- Function to get doctors by specialty
CREATE OR REPLACE FUNCTION public.get_doctors_by_specialty(specialty_name TEXT)
RETURNS TABLE (
    id UUID,
    first_name TEXT,
    last_name TEXT,
    specialty TEXT,
    clinic_address TEXT,
    photo_url TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        dp.id,
        dp.first_name,
        dp.last_name,
        s.name AS specialty,
        dp.clinic_address,
        dp.photo_url
    FROM public.doctor_profiles dp
    JOIN public.specialties s ON dp.specialty_id = s.id
    WHERE s.name ILIKE '%' || specialty_name || '%'
    AND dp.approval_status = 'approved';
    
    RETURN;
END;
$$ LANGUAGE plpgsql;

-- Function to approve a patient
CREATE OR REPLACE FUNCTION public.approve_patient(patient_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE public.patient_profiles
    SET approval_status = 'approved'
    WHERE id = patient_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to approve a doctor
CREATE OR REPLACE FUNCTION public.approve_doctor(doctor_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE public.doctor_profiles
    SET approval_status = 'approved'
    WHERE id = doctor_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to reject a patient
CREATE OR REPLACE FUNCTION public.reject_patient(patient_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE public.patient_profiles
    SET approval_status = 'rejected'
    WHERE id = patient_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to reject a doctor
CREATE OR REPLACE FUNCTION public.reject_doctor(doctor_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE public.doctor_profiles
    SET approval_status = 'rejected'
    WHERE id = doctor_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to attend a patient
CREATE OR REPLACE FUNCTION public.attend_patient(
    appointment_id UUID,
    treatment_text TEXT
)
RETURNS VOID AS $$
BEGIN
    UPDATE public.appointments
    SET 
        status = 'attended',
        treatment = treatment_text
    WHERE id = appointment_id
    AND status = 'pending';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to cancel appointment by doctor
CREATE OR REPLACE FUNCTION public.cancel_appointment_by_doctor(appointment_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE public.appointments
    SET status = 'cancelled_by_doctor'
    WHERE id = appointment_id
    AND status = 'pending';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to cancel appointment by patient
CREATE OR REPLACE FUNCTION public.cancel_appointment_by_patient(appointment_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE public.appointments
    SET status = 'cancelled_by_patient'
    WHERE id = appointment_id
    AND status = 'pending';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get most active doctors (for reports)
CREATE OR REPLACE FUNCTION public.get_most_active_doctors(limit_count INTEGER DEFAULT 10)
RETURNS TABLE (
    doctor_id UUID,
    doctor_name TEXT,
    specialty TEXT,
    attended_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        dp.id,
        dp.first_name || ' ' || dp.last_name AS doctor_name,
        s.name AS specialty,
        COUNT(a.id) AS attended_count
    FROM public.doctor_profiles dp
    JOIN public.specialties s ON dp.specialty_id = s.id
    LEFT JOIN public.appointments a ON dp.id = a.doctor_id AND a.status = 'attended'
    GROUP BY dp.id, doctor_name, s.name
    ORDER BY attended_count DESC
    LIMIT limit_count;
    
    RETURN;
END;
$$ LANGUAGE plpgsql;

-- Function to get most demanded specialties (for reports)
CREATE OR REPLACE FUNCTION public.get_most_demanded_specialties(limit_count INTEGER DEFAULT 10)
RETURNS TABLE (
    specialty TEXT,
    appointment_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.name AS specialty,
        COUNT(a.id) AS appointment_count
    FROM public.specialties s
    JOIN public.doctor_profiles dp ON s.id = dp.specialty_id
    LEFT JOIN public.appointments a ON dp.id = a.doctor_id
    GROUP BY s.name
    ORDER BY appointment_count DESC
    LIMIT limit_count;
    
    RETURN;
END;
$$ LANGUAGE plpgsql;

-- RLS Policies

-- Enable Row Level Security
ALTER TABLE public.patient_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.doctor_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.doctor_schedules ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.appointments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.specialties ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_config ENABLE ROW LEVEL SECURITY;

-- Patient Profiles Policies
CREATE POLICY "Patients can view their own profile" ON public.patient_profiles
    FOR SELECT USING (
        auth.uid() = id
    );

CREATE POLICY "Patients can update their own profile" ON public.patient_profiles
    FOR UPDATE USING (
        auth.uid() = id
    );

CREATE POLICY "Doctors can view approved patient profiles" ON public.patient_profiles
    FOR SELECT USING (
        (SELECT authorize('patient.read')) AND
        approval_status = 'approved'
    );

CREATE POLICY "Admins can view all patient profiles" ON public.patient_profiles
    FOR ALL USING (
        (SELECT authorize('patient.read'))
    );

-- Doctor Profiles Policies
CREATE POLICY "Doctors can view their own profile" ON public.doctor_profiles
    FOR SELECT USING (
        auth.uid() = id
    );

CREATE POLICY "Doctors can update their own profile" ON public.doctor_profiles
    FOR UPDATE USING (
        auth.uid() = id
    );

CREATE POLICY "Patients can view approved doctor profiles" ON public.doctor_profiles
    FOR SELECT USING (
        approval_status = 'approved'
    );

CREATE POLICY "Admins can view all doctor profiles" ON public.doctor_profiles
    FOR ALL USING (
        (SELECT authorize('doctor.read'))
    );

-- Doctor Schedules Policies
CREATE POLICY "Doctors can manage their own schedules" ON public.doctor_schedules
    FOR ALL USING (
        auth.uid() = doctor_id
    );

CREATE POLICY "Anyone can view doctor schedules" ON public.doctor_schedules
    FOR SELECT USING (true);

-- Appointments Policies
CREATE POLICY "Patients can view their own appointments" ON public.appointments
    FOR SELECT USING (
        auth.uid() = patient_id
    );

CREATE POLICY "Patients can create appointments" ON public.appointments
    FOR INSERT WITH CHECK (
        auth.uid() = patient_id
    );

CREATE POLICY "Patients can cancel their own appointments" ON public.appointments
    FOR UPDATE USING (
        auth.uid() = patient_id AND
        status = 'pending'
    ) WITH CHECK (
        status = 'cancelled_by_patient'
    );

CREATE POLICY "Doctors can view their appointments" ON public.appointments
    FOR SELECT USING (
        auth.uid() = doctor_id
    );

CREATE POLICY "Doctors can update their appointments" ON public.appointments
    FOR UPDATE USING (
        auth.uid() = doctor_id AND
        status = 'pending'
    );

CREATE POLICY "Admins can view all appointments" ON public.appointments
    FOR SELECT USING (
        (SELECT authorize('appointment.read'))
    );

-- Specialties Policies
CREATE POLICY "Anyone can view specialties" ON public.specialties
    FOR SELECT USING (true);

CREATE POLICY "Admins can manage specialties" ON public.specialties
    FOR ALL USING (
        (SELECT authorize('doctor.update'))
    );

-- User Roles Policies
CREATE POLICY "Users can view their own roles" ON public.user_roles
    FOR SELECT USING (
        auth.uid() = user_id
    );

CREATE POLICY "Admins can manage roles" ON public.user_roles
    FOR ALL USING (
        (auth.jwt() ->> 'user_role')::text = 'admin'
    );

-- Role Permissions Policies
CREATE POLICY "Users can view role permissions" ON public.role_permissions
    FOR SELECT USING (true);

CREATE POLICY "Admins can manage role permissions" ON public.role_permissions
    FOR ALL USING (
        (auth.jwt() ->> 'user_role')::text = 'admin'
    );

-- Admin Config Policies
CREATE POLICY "Only admins can access admin config" ON public.admin_config
    FOR ALL USING (
        (auth.jwt() ->> 'user_role')::text = 'admin'
    );

-- Grant necessary privileges to Supabase auth hooks
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
GRANT SELECT ON TABLE public.user_roles TO supabase_auth_admin;
GRANT SELECT ON TABLE public.patient_profiles TO supabase_auth_admin;
GRANT SELECT ON TABLE public.doctor_profiles TO supabase_auth_admin;

-- Revoke privileges from public and authenticated roles
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;

-- Email notification function (needs pg_notify extension or external service integration)
CREATE OR REPLACE FUNCTION public.notify_appointment_cancellation()
RETURNS TRIGGER AS $$
BEGIN
    -- This is a placeholder for email notification
    -- In a real implementation, you would use pg_notify or a webhook to trigger an email
    -- The backend would listen for these events and send the actual email
    RAISE NOTICE 'Appointment cancelled: Doctor % cancelled appointment for patient %', 
                 NEW.doctor_id, NEW.patient_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER notify_appointment_cancellation_trigger
AFTER UPDATE ON public.appointments
FOR EACH ROW
WHEN (NEW.status = 'cancelled_by_doctor')
EXECUTE FUNCTION public.notify_appointment_cancellation();


here it is changed
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event JSONB)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    claims JSONB;
    user_role public.app_role;
    is_admin BOOLEAN;
    is_doctor BOOLEAN;
    is_patient BOOLEAN;
    user_id UUID;
BEGIN
    user_id := (event->>'user_id')::UUID;
    claims := event->'claims';

    -- Check user roles - FIXED AMBIGUOUS COLUMN REFERENCES
    SELECT EXISTS (
        SELECT 1 FROM public.user_roles 
        WHERE public.user_roles.user_id = custom_access_token_hook.user_id AND role = 'admin'
    ) INTO is_admin;

    SELECT EXISTS (
        SELECT 1 FROM public.user_roles 
        WHERE public.user_roles.user_id = custom_access_token_hook.user_id AND role = 'doctor'
    ) INTO is_doctor;

    SELECT EXISTS (
        SELECT 1 FROM public.user_roles 
        WHERE public.user_roles.user_id = custom_access_token_hook.user_id AND role = 'patient'
    ) INTO is_patient;

    -- Rest of function remains the same
    claims := jsonb_set(claims, '{is_admin}', to_jsonb(is_admin));
    claims := jsonb_set(claims, '{is_doctor}', to_jsonb(is_doctor));
    claims := jsonb_set(claims, '{is_patient}', to_jsonb(is_patient));

    IF is_admin THEN
        user_role := 'admin';
    ELSIF is_doctor THEN
        user_role := 'doctor';
    ELSIF is_patient THEN
        user_role := 'patient';
    END IF;

    IF user_role IS NOT NULL THEN
        claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    END IF;

    event := jsonb_set(event, '{claims}', claims);
    RETURN event;
END;
$$;



latest oneCREATE OR REPLACE FUNCTION public.custom_access_token_hook(event JSONB)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    claims JSONB;
    user_role public.app_role;
    is_admin BOOLEAN;
    is_doctor BOOLEAN;
    is_patient BOOLEAN;
    current_user_id UUID;  -- Changed variable name to avoid ambiguity
BEGIN
    current_user_id := (event->>'user_id')::UUID;
    claims := event->'claims';

    -- Check user roles with renamed variable
    SELECT EXISTS (
        SELECT 1 FROM public.user_roles 
        WHERE user_roles.user_id = current_user_id AND role = 'admin'
    ) INTO is_admin;

    SELECT EXISTS (
        SELECT 1 FROM public.user_roles 
        WHERE user_roles.user_id = current_user_id AND role = 'doctor'
    ) INTO is_doctor;

    SELECT EXISTS (
        SELECT 1 FROM public.user_roles 
        WHERE user_roles.user_id = current_user_id AND role = 'patient'
    ) INTO is_patient;

    -- Rest of function remains the same
    claims := jsonb_set(claims, '{is_admin}', to_jsonb(is_admin));
    claims := jsonb_set(claims, '{is_doctor}', to_jsonb(is_doctor));
    claims := jsonb_set(claims, '{is_patient}', to_jsonb(is_patient));

    IF is_admin THEN
        user_role := 'admin';
    ELSIF is_doctor THEN
        user_role := 'doctor';
    ELSIF is_patient THEN
        user_role := 'patient';
    END IF;

    IF user_role IS NOT NULL THEN
        claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    END IF;

    event := jsonb_set(event, '{claims}', claims);
    RETURN event;
END;
$$;



latest addition
-- Fix the get_available_time_slots function to properly handle whitespace
CREATE OR REPLACE FUNCTION public.get_available_time_slots(
    doctor_id UUID,
    date_to_check DATE
)
RETURNS TABLE (
    available_slot TIME
) AS $$
DECLARE
    day_to_check day_of_week;
    start_hour TIME;
    end_hour TIME;
    slot_interval INTERVAL := '30 minutes';
    current_slot TIME;
    day_name TEXT;
BEGIN
    -- Convert date to day of week with proper whitespace handling
    SELECT LOWER(TRIM(TO_CHAR(date_to_check, 'day'))) INTO day_name;
    
    -- Explicitly handle day names
    CASE day_name
        WHEN 'monday' THEN day_to_check := 'monday'::day_of_week;
        WHEN 'tuesday' THEN day_to_check := 'tuesday'::day_of_week;
        WHEN 'wednesday' THEN day_to_check := 'wednesday'::day_of_week;
        WHEN 'thursday' THEN day_to_check := 'thursday'::day_of_week;
        WHEN 'friday' THEN day_to_check := 'friday'::day_of_week;
        WHEN 'saturday' THEN day_to_check := 'saturday'::day_of_week;
        WHEN 'sunday' THEN day_to_check := 'sunday'::day_of_week;
        ELSE RAISE EXCEPTION 'Invalid day name: %', day_name;
    END CASE;

    -- Get doctor's schedule for this day
    SELECT start_time, end_time INTO start_hour, end_hour
    FROM public.doctor_schedules
    WHERE doctor_schedules.doctor_id = get_available_time_slots.doctor_id
    AND day = day_to_check;

    -- Return empty set if no schedule found for this day
    IF start_hour IS NULL THEN
        RETURN;
    END IF;

    -- Generate all slots from start to end
    current_slot := start_hour;
    WHILE current_slot < end_hour LOOP
        -- Check if slot is available (not booked)
        IF NOT EXISTS (
            SELECT 1 FROM public.appointments
            WHERE appointments.doctor_id = get_available_time_slots.doctor_id
            AND appointment_date = date_to_check
            AND appointment_time = current_slot
            AND status = 'pending'
        ) THEN
            available_slot := current_slot;
            RETURN NEXT;
        END IF;
        
        -- Move to next slot
        current_slot := current_slot + slot_interval;
    END LOOP;
    
    RETURN;
END;
$$ LANGUAGE plpgsql;


latest change of function-- Fix the check_appointment_time function to properly handle whitespace
CREATE OR REPLACE FUNCTION check_appointment_time()
RETURNS TRIGGER AS $$
DECLARE
    day_name TEXT;
    doctor_day day_of_week;
    schedule_exists BOOLEAN;
    day_matches BOOLEAN;
    time_within_range BOOLEAN;
BEGIN
    -- Convert date to day of week with proper whitespace handling
    SELECT LOWER(TRIM(TO_CHAR(NEW.appointment_date, 'day'))) INTO day_name;
    
    -- Explicitly handle day names
    CASE day_name
        WHEN 'monday' THEN doctor_day := 'monday'::day_of_week;
        WHEN 'tuesday' THEN doctor_day := 'tuesday'::day_of_week;
        WHEN 'wednesday' THEN doctor_day := 'wednesday'::day_of_week;
        WHEN 'thursday' THEN doctor_day := 'thursday'::day_of_week;
        WHEN 'friday' THEN doctor_day := 'friday'::day_of_week;
        WHEN 'saturday' THEN doctor_day := 'saturday'::day_of_week;
        WHEN 'sunday' THEN doctor_day := 'sunday'::day_of_week;
        ELSE RAISE EXCEPTION 'Invalid day name: %', day_name;
    END CASE;

    -- Check if doctor works on this day
    SELECT EXISTS (
        SELECT 1 FROM public.doctor_schedules 
        WHERE doctor_id = NEW.doctor_id 
        AND day = doctor_day
    ) INTO day_matches;

    IF NOT day_matches THEN
        RAISE EXCEPTION 'Doctor does not work on this day';
    END IF;

    -- Check if time is within doctor's working hours
    SELECT EXISTS (
        SELECT 1 FROM public.doctor_schedules 
        WHERE doctor_id = NEW.doctor_id 
        AND day = doctor_day
        AND NEW.appointment_time BETWEEN start_time AND end_time
    ) INTO time_within_range;

    IF NOT time_within_range THEN
        RAISE EXCEPTION 'Appointment time is outside doctor''s working hours';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;